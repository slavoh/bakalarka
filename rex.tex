\section {Radomized Exchange Algoritmus}

V tejto podkapitole popíšeme randomized exchange algoritmus (REX) predstavený v \cite{rex_harman}. Dá sa na neho pozerať ako na špeciálny prípad SAM algoritmu. REX algoritmus kombinuje kroky VEM algoritmu a pažravých algoritmov. Podľa \cite{rex_harman} je REX algoritmus v praxi rýchlejší ako všetky porovnané state--of--the--art algoritmy na riešenie problému optimálneho riadenia. Na uvedenie predstavy o rýchlosti REX algoritmu, medzi známe algoritmy na riešenie problému optimálneho riadenia patria algoritmy konvergujúce v lineárnom čase (napr. Khachiyanov algoritmus). Konvergencia v lineárnom čase znamená, že do vzialenosti $\epsilon$ od optima dôjdu v čase $\mathcal{O}(log(\frac{1}{\epsilon}))$ \\

Nech $\mathbf w$ je regulárny návrh, nech $\mathbf {d(w)}$ je $n$--rozmerný vektor s komponentami $d_x(\mathbf w)$. Hlavná myšlienka REX algoritmu je počnúc inicializovaným regulárnym návrhom $\mathbf w$ iteratívne vyberať niekoľko návrhov (ich počet sa bude líšiť v rámci iterácii) a náhodne vykonať optimálnu výmenu váh medzi vybranými bodmi. Optimálna výmena váh je analogická LBE kroku VEM algoritmu. Voľba návrhov závisí na $\mathbf{d(w)}$. Kroky REX algoritmu budú nasledovné:

\begin{itemize}
	\item \textbf{Krok LBE.} Pri danom návrhu $\mathbf w$, vypočítaj $\mathbf {d(w)}$ a urob LBE krok daný nasledovne: $$\alpha^* \leftarrow \argmax_{\alpha \in [-w_l, w_k] \}} \{ \Phi(\mathbf M(\mathbf w+\alpha \mathbf e_l -\alpha \mathbf e_k)),$$ kde 
	$k \in \argmin_{u \in \text{supp}(\mathbf w)} \{ d_u(\mathbf w)\}, l \in \argmax_{v \in \mathfrak X} \{ d_v(\mathbf w)\}$. Optimálny krok $\alpha^*_{k,l}(\mathbf w)$ nazvime \textit{nulujúci}, ak je rovný buď $-w_l$ alebo $w_k$. To zodpovedá prípadu, keď sme sa optimálnym krokom pohli do niektorého z návrh $w_l$ alebo $w_k$.

	\item \textbf{Výber aktívneho podpriestoru.} Podpriestor $S \subset \mathfrak X$, v ktorom sa pohneme bude zvolený ako zjednotenie dvoch množín. Jednou vybranou pažravým procesom ($S_\text{greedy}$) a druhou ako nosič návrhu $\mathbf w$ ($S_\text{support}$).
	\begin{itemize}
		\item \textbf{Pažravá množina.} Nech $L=\min (\gamma m, n)$ je počet návrhov, ktoré vyberieme. Potom zvoľ $S_\text{greedy}$ ako $$S_\text{greedy} = \{l_1^*, \dots, l_L^* \} \subset \mathfrak X,$$ kde $l_i^*$ je najväčšia zložka vektoru $\mathbf d(\mathbf w)$.
		\item \textbf{Nosič.} Nastav $$S_\text{support}(w)=\text{supp}(\mathbf w).$$ Označme $K$ veľkosť nosiča, $K= |\text{supp}(\mathbf w)|$.
		\item \textbf{Aktívny podpriestor.} Aktívny podpriestor $S$ je definovaný ako $$S=S_\text{greedy} \cup S_\text{support}.$$ Váhy návrhov mimo aktívneho podpriestoru nebudú upravované v tejto iterácii.
	\end{itemize}

	\item \textbf{Krok v aktívnom podpriestore.} Teraz vykonáme krok, v ktorom aktualizujeme hodnoty $w_v$ pre $v \in S$. Návrhy $w_v$ pre $v \not \in S$ ostanú nezmenené.
	\begin{itemize}
		\item \textbf{Tvorba párov.} Nech $(k_1, \dots, k_K)$ je uniformne náhodná premutácia $S_\text{support}$ a nech $(l_1, \dots, l_L)$ je uniformne náhodná permutácia $S_\text{greedy}$. Potom postupnosť aktívnych návrhov je $$ (k_1,l_1), (k_2, l_1), \dots, (k_1, l_L), (k_2,l_L), \dots, (k_K, l_L) $$.
		\item \textbf{Aktualizácia.} Vykonaj postupne všetky $\Phi$--optimálne LBE kroky medzi návrhmi z $ (k_1,l_1), \dots, (k_K, l_L)$ s prisluchajúcimi aktualizáciami $\mathbf w$ a $\mathbf {M(w)}$.
	\end{itemize}
\end{itemize}

REX algoritmus vyzerá nasledovne:

\begin{algorithm}[H]
	\caption{REX algoritmus \cite{rex_harman}}
	\label{rex}
	\begin{algorithmic}[1]
		\State Zvoľ regulárny $n$--rozmerný návrh $\mathbf w$
		\While {$\mathbf w$ nespĺňa podmienky zastavenia}
			\State Urob LBE krok vo $\mathbf w$
			\State Nech $k$ je vektor zodpovedajúci náhodnej permutácii prvkov supp$(\mathbf w)$
			\State Nech $l$ je vektor zodpovedajúci náhodnej permutácii $L=\min(\gamma m, n)$ indexov prvkov $\mathbf {d(w)}$
			\For {$l=1 \dots L$}
				\For {$l=1 \dots K$}
					\State $\alpha^* \leftarrow \argmax_{\alpha \in [-w_l, w_k]} \{ \Phi(\mathbf M(\mathbf w+\alpha \mathbf e_l -\alpha \mathbf e_k))\}$
					\If {LBE krok bol nulujúci alebo $\alpha^* = -w_l$ alebo $\alpha^* = w_k$ }
						\State $w_k \leftarrow w_k - \alpha^*$
						\State $w_l \leftarrow w_l + \alpha^*$
					\EndIf
				\EndFor
			\EndFor
		\EndWhile
		\State Vráť $\mathbf w$
	\end{algorithmic}
\end{algorithm}

